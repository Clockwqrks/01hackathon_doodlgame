<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Auction Whiteboard Game - Bulletproof Drawing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #fff;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .connection-status {
            background: #f8f9fa;
            border-bottom: 2px solid #007bff;
            padding: 10px 20px;
            text-align: center;
            font-weight: 600;
        }

        .connection-status.connected {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }

        .game-status {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .game-info {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .game-timer {
            font-size: 24px;
            color: #ffeb3b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .money-display {
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 16px;
        }

        .round-info {
            font-size: 14px;
        }

        .phase-info {
            font-size: 14px;
            background: rgba(255,255,255,0.1);
            padding: 4px 12px;
            border-radius: 15px;
        }

        .game-controls {
            display: flex;
            gap: 10px;
        }

        .game-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .game-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .game-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .round-timer {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 20px 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-width: 200px;
            text-align: center;
            display: none;
            border: 3px solid rgba(255, 255, 255, 0.2);
        }

        .round-timer.active {
            display: block;
            animation: slideInLeft 0.5s ease-out;
        }

        @keyframes slideInLeft {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .timer-label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .timer-display {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-family: 'Courier New', monospace;
        }

        .timer-phase {
            font-size: 12px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .timer-display.warning {
            color: #ffc107;
            animation: pulse-warning 1s infinite;
        }

        .timer-display.critical {
            color: #dc3545;
            animation: pulse-critical 0.5s infinite;
        }

        @keyframes pulse-warning {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes pulse-critical {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .lobby-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .lobby-panel {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .lobby-panel h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 28px;
        }

        .lobby-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 30px 0;
        }

        .lobby-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 15px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .lobby-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .lobby-btn.secondary {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .game-code-display {
            background: #f8f9fa;
            border: 2px dashed #007bff;
            border-radius: 10px;
            padding: 30px;
            margin: 20px 0;
            font-size: 36px;
            font-weight: bold;
            color: #007bff;
            letter-spacing: 8px;
            font-family: monospace;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            text-align: left;
            margin: 20px 0;
        }

        .form-group label {
            font-weight: 600;
            color: #333;
        }

        .form-group input {
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            font-family: inherit;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        .player-settings {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }

        .settings-row label {
            font-weight: 600;
            color: #333;
        }

        .settings-row input, .settings-row select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            width: 120px;
        }

        .prompt-display {
            background: #f8f9fa;
            border-bottom: 3px solid #007bff;
            padding: 15px 20px;
            text-align: center;
            display: none;
        }

        .prompt-display.active {
            display: block;
        }

        .prompt-text {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .prompt-subtitle {
            font-size: 14px;
            color: #666;
        }

        .toolbar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: #f5f5f5;
            border-bottom: 1px solid #e0e0e0;
            flex-wrap: wrap;
        }

        .markers {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .marker {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #fff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .marker:hover {
            transform: scale(1.1);
        }

        .marker.active {
            transform: scale(1.2);
            border-color: #333;
            box-shadow: 0 0 0 2px #333;
        }

        .marker.red { background: #ff6b6b; }
        .marker.orange { background: #ffa726; }
        .marker.yellow { background: #ffee58; }
        .marker.green { background: #66bb6a; }
        .marker.blue { background: #42a5f5; }
        .marker.purple { background: #ab47bc; }
        .marker.black { background: #424242; }

        .tools {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .tool {
            width: 35px;
            height: 35px;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            background: #fff;
            color: #555;
        }

        .tool:hover {
            transform: scale(1.1);
            border-color: #999;
        }

        .tool.active {
            transform: scale(1.1);
            border-color: #333;
            background: #333;
            color: white;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="range"] {
            width: 80px;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #333;
            border-radius: 50%;
            cursor: pointer;
        }

        .thickness-display {
            font-size: 12px;
            color: #555;
            min-width: 35px;
            background: #f0f0f0;
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid #ddd;
            text-align: center;
        }

        input[type="color"] {
            width: 35px;
            height: 35px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            background: none;
            padding: 0;
        }

        button {
            background: #fff;
            color: #555;
            border: 2px solid #ddd;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
            min-width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            background: #333;
            color: white;
            border-color: #333;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #fff;
            padding: 20px;
            position: relative;
        }

        .bulletproof-canvas {
            position: absolute;
            z-index: 9999;
            pointer-events: auto;
            border: 3px solid #007bff;
            background: white;
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .bidding-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .bidding-overlay.active {
            display: flex;
        }

        .bidding-panel {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
        }

        .bidding-artwork {
            width: 300px;
            height: 200px;
            border: 3px solid #ddd;
            border-radius: 10px;
            margin: 0 auto 20px;
            background: #f9f9f9;
        }

        .bidding-info h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .current-bid {
            font-size: 32px;
            color: #e74c3c;
            font-weight: bold;
            margin: 20px 0;
        }

        .bid-timer {
            font-size: 18px;
            color: #f39c12;
            margin-bottom: 20px;
        }

        .bid-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
        }

        .quick-bid-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .quick-bid-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
        }

        .quick-bid-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .quick-bid-btn:active {
            transform: translateY(0);
        }

        .bid-input {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            width: 120px;
            text-align: center;
        }

        .bid-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .bid-btn:hover {
            background: #219a52;
            transform: translateY(-2px);
        }

        .players-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            min-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
        }

        .players-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-count {
            background: #007bff;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .player-name {
            font-weight: 500;
            color: #333;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .player-money {
            color: #27ae60;
            font-weight: 600;
        }

        .player-values {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }

        .results-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .results-modal.active {
            display: flex;
        }

        .results-panel {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 700px;
            width: 90%;
            text-align: center;
            max-height: 80vh;
            overflow-y: auto;
        }

        .final-standings {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 30px 0;
        }

        .standing-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #007bff;
        }

        .standing-item.winner {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            border-left-color: #ffa500;
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3);
        }

        .chat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 400px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            border: 1px solid #e0e0e0;
        }

        .chat-header {
            background: #f8f9fa;
            padding: 12px 16px;
            border-bottom: 1px solid #e0e0e0;
            border-radius: 12px 12px 0 0;
            font-weight: 600;
            color: #333;
            text-align: center;
        }

        .chat-messages {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
        }

        .message {
            margin-bottom: 12px;
            padding: 8px 12px;
            background: #f1f3f4;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.4;
        }

        .message.own {
            background: #007bff;
            color: white;
            margin-left: auto;
            text-align: right;
        }

        .message .sender {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 4px;
            opacity: 0.8;
        }

        .chat-input-container {
            padding: 12px 16px;
            border-top: 1px solid #e0e0e0;
        }

        .chat-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
            font-size: 14px;
            font-family: inherit;
        }

        .back-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }

        .copy-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #28a745);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">
        Create a game or join with a code to start playing
    </div>

    <div class="lobby-modal" id="lobbyModal">
        <div class="lobby-panel">
            <h2>Bulletproof Auction Game</h2>
            <p>Enhanced multiplayer with unstoppable drawing</p>
            
            <div id="lobbyMain" class="lobby-options">
                <button class="lobby-btn" onclick="roomManager.createRoom()">Create Room</button>
                <button class="lobby-btn secondary" onclick="roomManager.showJoinRoom()">Join Room</button>
            </div>

            <div id="createRoomForm" style="display: none;">
                <h3>Room Created!</h3>
                <div class="game-code-display" id="roomCode">ABCD</div>
                <button class="copy-btn" onclick="copyToClipboard('roomCode')">Copy Code</button>
                
                <div class="player-settings">
                    <h4>Game Settings</h4>
                    <div class="settings-row">
                        <label>Max Players:</label>
                        <select id="maxPlayers">
                            <option value="2">2 Players</option>
                            <option value="4" selected>4 Players</option>
                            <option value="6">6 Players</option>
                            <option value="8">8 Players</option>
                        </select>
                    </div>
                    <div class="settings-row">
                        <label>Drawing Time:</label>
                        <select id="drawingTime">
                            <option value="60">60 seconds</option>
                            <option value="90" selected>90 seconds</option>
                            <option value="120">120 seconds</option>
                        </select>
                    </div>
                    <div class="settings-row">
                        <label>Bidding Time:</label>
                        <select id="biddingTime">
                            <option value="20">20 seconds</option>
                            <option value="30" selected>30 seconds</option>
                            <option value="45">45 seconds</option>
                        </select>
                    </div>
                </div>
                
                <div id="waitingPlayers"></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="playerProgress"></div>
                </div>
                <button class="lobby-btn" id="startGameBtn" onclick="roomManager.startGame()" style="display: none;">Start Game</button>
                <button class="back-btn" onclick="roomManager.closeRoom()">Close Room</button>
            </div>

            <div id="joinRoomForm" style="display: none;">
                <h3>Join Room</h3>
                <div class="form-group">
                    <label>Your Name:</label>
                    <input type="text" id="playerName" placeholder="Enter your name" value="Player" maxlength="20">
                </div>
                <div class="form-group">
                    <label>Room Code:</label>
                    <input type="text" id="roomCodeInput" placeholder="ABCD" maxlength="4">
                </div>
                <button class="lobby-btn secondary" onclick="roomManager.joinRoom()">Join</button>
                <button class="back-btn" onclick="roomManager.showMain()">Back</button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="round-timer" id="roundTimer">
            <div class="timer-label">Drawing Time</div>
            <div class="timer-display" id="timerDisplay">1:30</div>
            <div class="timer-phase" id="timerPhase">Round 1 of 6</div>
        </div>

        <div class="game-status">
            <div class="game-info">
                <div class="game-timer" id="gameTimer">Ready to Start</div>
                <div class="money-display" id="moneyDisplay">Money: $10,000</div>
                <div class="round-info" id="roundInfo">Round 1 of 6</div>
                <div class="phase-info" id="phaseInfo">Lobby</div>
            </div>
            <div class="game-controls">
                <button class="game-btn" id="submitDrawing" onclick="gameManager.submitDrawing()" disabled>Submit Drawing</button>
            </div>
        </div>

        <div class="prompt-display" id="promptDisplay">
            <div class="prompt-text" id="promptText">Draw a happy cat wearing a hat</div>
            <div class="prompt-subtitle">You have 90 seconds to complete your masterpiece!</div>
        </div>

        <div class="players-panel">
            <div class="players-title">
                Players 
                <div class="player-count" id="playerCount">0</div>
            </div>
            <div id="playersList"></div>
        </div>
        
        <div class="toolbar">
            <div class="markers">
                <div class="marker red active" data-color="#ff6b6b"></div>
                <div class="marker orange" data-color="#ffa726"></div>
                <div class="marker yellow" data-color="#ffee58"></div>
                <div class="marker green" data-color="#66bb6a"></div>
                <div class="marker blue" data-color="#42a5f5"></div>
                <div class="marker purple" data-color="#ab47bc"></div>
                <div class="marker black" data-color="#424242"></div>
            </div>
            
            <div class="tools">
                <div class="tool brush active" data-tool="brush">🖌️</div>
                <div class="tool eraser" data-tool="eraser">🧽</div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <input type="range" id="thickness" min="1" max="30" value="5">
                    <span class="thickness-display" id="thicknessValue">5px</span>
                </div>
                
                <input type="color" id="colorPicker" value="#ff6b6b">
                
                <button id="undoButton">↶</button>
                <button id="clearCanvas">🗑️</button>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="bulletproof-canvas" class="bulletproof-canvas"></canvas>
        </div>

        <div class="chat-container">
            <div class="chat-header">Game Chat</div>
            <div class="chat-messages" id="chatMessages">
                <div class="message">
                    <div class="sender">System</div>
                    <div class="content">Join a room to start chatting!</div>
                </div>
            </div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." disabled>
            </div>
        </div>
    </div>

    <div class="bidding-overlay" id="biddingOverlay">
        <div class="bidding-panel">
            <h3>Artwork Auction</h3>
            <canvas class="bidding-artwork" id="biddingArtwork" width="300" height="200"></canvas>
            <div class="bidding-info">
                <div class="prompt-text" id="biddingPrompt">Drawing Prompt</div>
                <div class="current-bid" id="currentBid">Current Bid: $0</div>
                <div class="bid-timer" id="bidTimer">Time Remaining: 30s</div>
            </div>
            <div class="bid-controls">
                <input type="number" class="bid-input" id="bidInput" placeholder="Custom bid" min="0">
                <button class="bid-btn" onclick="gameManager.placeBid()">Place Bid</button>
                <div class="quick-bid-buttons">
                    <button class="quick-bid-btn" onclick="gameManager.placeBid(500)">+$500</button>
                    <button class="quick-bid-btn" onclick="gameManager.placeBid(1000)">+$1,000</button>
                    <button class="quick-bid-btn" onclick="gameManager.placeBid(1500)">+$1,500</button>
                </div>
            </div>
        </div>
    </div>

    <div class="results-modal" id="resultsModal">
        <div class="results-panel">
            <h2>Game Results</h2>
            <div class="final-standings" id="finalStandings"></div>
            <button class="lobby-btn" onclick="gameManager.resetGame()">Play Again</button>
        </div>
    </div>

    <script>
        // BULLETPROOF DRAWING SYSTEM - CANNOT BE STOPPED
        class BulletproofCanvas {
            constructor() {
                this.canvas = document.getElementById('bulletproof-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.isDrawing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.currentColor = '#ff6b6b';
                this.currentThickness = 5;
                this.history = [];
                this.historyStep = -1;
                
                this.setupCanvas();
                this.setupEvents();
                this.setupProtection();
                this.setupToolbarSync();
                
                console.log('🛡️ BULLETPROOF CANVAS ACTIVE - NOTHING CAN STOP DRAWING');
            }
            
            setupCanvas() {
                this.canvas.width = 1000;
                this.canvas.height = 600;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.strokeStyle = this.currentColor;
                this.ctx.lineWidth = this.currentThickness;
                this.saveState();
            }
            
            setupEvents() {
                // Mouse events with highest priority
                this.canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.startDrawing(e);
                }, true);
                
                this.canvas.addEventListener('mousemove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.draw(e);
                }, true);
                
                this.canvas.addEventListener('mouseup', () => this.stopDrawing(), true);
                this.canvas.addEventListener('mouseout', () => this.stopDrawing(), true);
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.startDrawing({
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                }, true);
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.draw({
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                }, true);
                
                this.canvas.addEventListener('touchend', () => this.stopDrawing(), true);
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                    }
                }, true);
            }
            
            setupProtection() {
                // Protect against canvas clearing
                const originalClearRect = this.ctx.clearRect;
                this.ctx.clearRect = (...args) => {
                    if (this.allowClear) {
                        return originalClearRect.apply(this.ctx, args);
                    }
                    console.log('🛡️ BLOCKED: Canvas clear attempt');
                };
                
                // Continuous protection with correct z-index
                setInterval(() => {
                    if (this.canvas.style.display === 'none') {
                        this.canvas.style.display = 'block';
                    }
                    if (this.canvas.style.pointerEvents === 'none') {
                        this.canvas.style.pointerEvents = 'auto';
                    }
                    // Keep canvas above content but below UI elements
                    const currentZ = parseInt(this.canvas.style.zIndex) || 0;
                    if (currentZ !== 100) {
                        this.canvas.style.zIndex = '100';
                    }
                }, 100);
            }
            
            setupToolbarSync() {
                // Color markers
                document.querySelectorAll('.marker').forEach(marker => {
                    marker.addEventListener('click', (e) => {
                        document.querySelectorAll('.marker').forEach(m => m.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentColor = e.target.dataset.color;
                        this.ctx.strokeStyle = this.currentColor;
                        document.getElementById('colorPicker').value = this.currentColor;
                    });
                });
                
                // Color picker
                document.getElementById('colorPicker').addEventListener('change', (e) => {
                    this.currentColor = e.target.value;
                    this.ctx.strokeStyle = this.currentColor;
                    document.querySelectorAll('.marker').forEach(m => m.classList.remove('active'));
                });
                
                // Thickness slider
                document.getElementById('thickness').addEventListener('input', (e) => {
                    this.currentThickness = e.target.value;
                    this.ctx.lineWidth = this.currentThickness;
                    document.getElementById('thicknessValue').textContent = `${e.target.value}px`;
                });
                
                // Clear button
                document.getElementById('clearCanvas').addEventListener('click', () => {
                    this.manualClear();
                });
                
                // Undo button
                document.getElementById('undoButton').addEventListener('click', () => {
                    this.undo();
                });
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
            
            startDrawing(e) {
                // Prevent drawing if game hasn't started or not in drawing phase
                if (!gameManager || gameManager.gameState !== 'drawing') {
                    console.log('🚫 Drawing blocked - game not in drawing phase');
                    return;
                }
                
                this.isDrawing = true;
                const pos = this.getMousePos(e);
                this.lastX = pos.x;
                this.lastY = pos.y;
                this.ctx.beginPath();
                this.ctx.moveTo(this.lastX, this.lastY);
            }
            
            draw(e) {
                if (!this.isDrawing) return;
                const pos = this.getMousePos(e);
                this.ctx.lineTo(pos.x, pos.y);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(pos.x, pos.y);
            }
            
            stopDrawing() {
                if (!this.isDrawing) return;
                this.isDrawing = false;
                setTimeout(() => this.saveState(), 50);
            }
            
            saveState() {
                this.historyStep++;
                if (this.historyStep < this.history.length) {
                    this.history.length = this.historyStep;
                }
                this.history.push(this.canvas.toDataURL());
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyStep--;
                }
            }
            
            undo() {
                if (this.historyStep > 0 && !this.isDrawing) {
                    this.historyStep--;
                    this.restoreState();
                }
            }
            
            restoreState() {
                const img = new Image();
                img.onload = () => {
                    this.allowClear = true;
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.drawImage(img, 0, 0);
                    this.allowClear = false;
                };
                img.src = this.history[this.historyStep];
            }
            
            manualClear() {
                // Only allow clearing during drawing phase or lobby
                if (!gameManager || (gameManager.gameState !== 'drawing' && gameManager.gameState !== 'lobby')) {
                    console.log('🚫 Canvas clear blocked - not in appropriate game phase');
                    return;
                }
                
                this.allowClear = true;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.allowClear = false;
                this.saveState();
            }
            
            getDrawingData() {
                return this.canvas.toDataURL();
            }
        }

        // Enhanced Game Manager with Full UI
        class GameManager {
            constructor() {
                this.gameState = 'lobby';
                this.currentRound = 1;
                this.maxRounds = 6;
                this.currentPlayer = 0;
                this.players = [];
                this.currentPrompt = '';
                this.currentArtwork = null;
                this.currentBid = 0;
                this.currentBidder = null;
                this.drawingTimer = null;
                this.biddingTimer = null;
                this.timeRemaining = 0;
                this.artworks = [];
                this.currentAuctionIndex = 0;
                this.submittedPlayers = [];
                this.gameSettings = {
                    drawingTime: 90,
                    biddingTime: 30
                };
                
                this.prompts = [
                    "A cat wearing sunglasses at a beach",
                    "A robot eating ice cream in space",
                    "A dragon flying over a modern city",
                    "An alien playing guitar on stage",
                    "A superhero walking a tiny dog",
                    "A pirate ship sailing through clouds",
                    "A wizard making coffee in a lab",
                    "A unicorn riding a motorcycle",
                    "A dinosaur wearing a business suit",
                    "A knight fighting a giant sandwich",
                    "An octopus playing piano in a jazz club",
                    "A penguin surfing on lava",
                    "A vampire at a sunny beach party",
                    "A ninja cooking in a food truck",
                    "A mermaid reading in a library",
                    "A ghost driving a race car",
                    "A bear wearing a crown and cape",
                    "A monkey in a space suit",
                    "A phoenix making pancakes",
                    "A troll gardening rainbow flowers"
                ];
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (this.gameState === 'drawing' && (e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                        e.preventDefault();
                        this.submitDrawing();
                    }
                });
            }

            initializeFromRoom(gameState) {
                console.log('Initializing from room state:', gameState.phase);
                
                this.players = gameState.players;
                this.gameState = gameState.phase;
                this.currentRound = gameState.round;
                this.currentPlayer = gameState.currentPlayer;
                this.gameSettings = gameState.settings || this.gameSettings;
                this.submittedPlayers = [];
                
                this.updateUI();
                
                // Only start drawing phase if we're not already in it and haven't started timer yet
                if (this.gameState === 'drawing' && !this.drawingTimer) {
                    console.log('Starting drawing phase from room initialization');
                    setTimeout(() => {
                        this.startDrawingPhase();
                    }, 1000);
                }
            }

            broadcastUpdate(update) {
                roomManager.fastBroadcast('gameUpdate', update);
            }

            handleRemoteUpdate(update) {
                // Handle timer updates for non-hosts
                if (update.type === 'timerUpdate' && !roomManager.isHost) {
                    this.timeRemaining = update.timeRemaining;
                    this.updateRoundTimer();
                    this.updateTimer();
                    return;
                }
                
                // Handle real-time bid updates
                if (update.type === 'bidUpdate') {
                    this.currentBid = update.currentBid;
                    this.currentBidder = update.currentBidder;
                    
                    // Update display immediately
                    document.getElementById('currentBid').textContent = `Current Bid: ${this.currentBid} (${update.bidderName})`;
                    document.getElementById('bidInput').value = this.currentBid + 500;
                    
                    this.updateUI();
                    return;
                }
                
                // Block other timer interference but allow legitimate updates
                const {timeRemaining, ...safeUpdates} = update;
                
                // Only update timeRemaining if it's a timer update
                if (update.type !== 'timerUpdate') {
                    Object.assign(this, safeUpdates);
                }
                
                // Prevent infinite loop of phase changes
                if (update.phase && update.phase !== this.gameState) {
                    console.log(`Phase change: ${this.gameState} -> ${update.phase}`);
                    this.gameState = update.phase;
                    
                    // Only start phases if we're not already in them
                    if (this.gameState === 'drawing' && !this.drawingTimer) {
                        this.startDrawingPhase();
                    } else if (this.gameState === 'bidding') {
                        this.startBiddingPhase();
                    } else if (this.gameState === 'results') {
                        this.endGame();
                    }
                }
                
                if (update.submittedPlayers) {
                    this.submittedPlayers = update.submittedPlayers;
                    this.updateSubmissionStatus();
                }
                
                this.updateUI();
            }

            startDrawingPhase() {
                // Prevent multiple calls to startDrawingPhase
                if (this.drawingPhaseStarted) {
                    console.log('Drawing phase already started, skipping...');
                    return;
                }
                
                this.drawingPhaseStarted = true;
                console.log('🎨 Starting drawing phase...');
                
                if (!this.currentPrompt) {
                    this.currentPrompt = this.prompts[Math.floor(Math.random() * this.prompts.length)];
                }
                
                // Show drawing UI
                document.getElementById('promptDisplay').classList.add('active');
                document.getElementById('promptText').textContent = this.currentPrompt;
                document.getElementById('phaseInfo').textContent = 'Drawing Phase';
                
                // Show and configure round timer
                const roundTimer = document.getElementById('roundTimer');
                const timerPhase = document.getElementById('timerPhase');
                const timerLabel = document.querySelector('.timer-label');
                
                if (roundTimer) {
                    roundTimer.classList.add('active');
                    timerPhase.textContent = `Round ${this.currentRound} of ${this.maxRounds}`;
                    if (timerLabel) {
                        timerLabel.textContent = 'Drawing Time';
                    }
                }
                
                // Initialize and START timer immediately
                this.timeRemaining = this.gameSettings.drawingTime;
                console.log(`⏰ Timer starting immediately: ${this.timeRemaining} seconds`);
                
                // Update display first
                this.updateRoundTimer();
                this.updateTimer();
                
                // ONLY HOST RUNS THE ACTUAL TIMER
                if (roomManager.isHost) {
                    // Clear any existing timer and start new one immediately
                    if (this.drawingTimer) {
                        clearInterval(this.drawingTimer);
                    }
                    
                    this.drawingTimer = setInterval(() => {
                        this.timeRemaining--;
                        
                        // Update local display
                        this.updateRoundTimer();
                        this.updateTimer();
                        
                        // Broadcast timer update to all players
                        this.broadcastUpdate({
                            type: 'timerUpdate',
                            timeRemaining: this.timeRemaining
                        });
                        
                        if (this.timeRemaining <= 0) {
                            console.log('⏰ Timer reached 0 - transitioning to bidding phase');
                            clearInterval(this.drawingTimer);
                            this.drawingTimer = null;
                            this.hideRoundTimer();
                            this.handleDrawingTimeUp();
                        }
                    }, 1000);
                }
                
                // Enable drawing submission
                document.getElementById('submitDrawing').disabled = false;
                this.updateUI();
            }

            updateRoundTimer() {
                const timerDisplay = document.getElementById('timerDisplay');
                if (!timerDisplay) return;
                
                const minutes = Math.floor(this.timeRemaining / 60);
                const seconds = this.timeRemaining % 60;
                timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                timerDisplay.classList.remove('warning', 'critical');
                
                if (this.timeRemaining <= 10) {
                    timerDisplay.classList.add('critical');
                } else if (this.timeRemaining <= 30) {
                    timerDisplay.classList.add('warning');
                }
            }
            
            hideRoundTimer() {
                const roundTimer = document.getElementById('roundTimer');
                if (roundTimer) {
                    roundTimer.classList.remove('active');
                }
            }

            handleDrawingTimeUp() {
                console.log('⏰ Drawing time is up! Forcing transition to bidding phase...');
                
                if (this.drawingTimer) {
                    clearInterval(this.drawingTimer);
                    this.drawingTimer = null;
                }

                // Force submit for current player if they haven't submitted
                this.forceSubmitAll();

                // Immediately transition to bidding phase
                setTimeout(() => {
                    this.gameState = 'bidding';
                    this.startBiddingPhase();
                    console.log('🎯 Bidding phase started automatically after timer expiry');
                }, 1000);
            }

            updateSubmissionStatus() {
                if (this.gameState !== 'drawing') return;
                
                const myPlayer = this.getMyPlayer();
                const gameTimer = document.getElementById('gameTimer');
                
                if (myPlayer && this.submittedPlayers.includes(myPlayer.id)) {
                    this.lockUserActions();
                    if (gameTimer) {
                        gameTimer.textContent = `Waiting for other players... (${this.submittedPlayers.length}/${this.players.length})`;
                    }
                } else {
                    if (gameTimer) {
                        gameTimer.textContent = `Drawing time! (${this.submittedPlayers.length}/${this.players.length} submitted)`;
                    }
                }
                
                // Check if all players have submitted - FIXED LOGIC
                console.log(`Submissions: ${this.submittedPlayers.length}/${this.players.length}`);
                if (this.submittedPlayers.length >= this.players.length && this.gameState === 'drawing') {
                    console.log('All players submitted - transitioning to bidding phase');
                    
                    // Clear the drawing timer since we're done early
                    if (this.drawingTimer) {
                        clearInterval(this.drawingTimer);
                        this.drawingTimer = null;
                    }
                    
                    this.hideRoundTimer();
                    
                    // Only host should trigger the transition
                    if (roomManager.isHost) {
                        this.broadcastUpdate({
                            phase: 'bidding',
                            artworks: this.artworks,
                            submittedPlayers: this.submittedPlayers,
                            currentAuctionIndex: 0,
                            currentBid: 0,
                            currentBidder: null
                        });
                    }
                    
                    setTimeout(() => {
                        this.startBiddingPhase();
                    }, 1000);
                }
            }

            getMyPlayer() {
                const myPlayerId = roomManager.localPlayer?.id;
                return this.players.find(p => p.id === myPlayerId);
            }
            
            async submitDrawing() {
                const myPlayer = this.getMyPlayer();
                if (this.gameState !== 'drawing' || !myPlayer) {
                    console.log('Cannot submit - wrong game state or no player');
                    return;
                }
                
                if (this.submittedPlayers && this.submittedPlayers.includes(myPlayer.id)) {
                    console.log('Already submitted');
                    return;
                }
                
                let imageData;
                if (window.bulletproofCanvas) {
                    imageData = window.bulletproofCanvas.getDrawingData();
                } else {
                    imageData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
                }
                
                const artwork = {
                    playerId: myPlayer.id,
                    playerName: myPlayer.name,
                    prompt: this.currentPrompt,
                    imageData: imageData,
                    actualValue: this.calculateArtworkValue()
                };
                
                this.artworks = [...(this.artworks || []), artwork];
                
                if (!this.submittedPlayers) this.submittedPlayers = [];
                this.submittedPlayers.push(myPlayer.id);
                
                console.log(`✅ ${myPlayer.name} submitted artwork. Total submissions: ${this.submittedPlayers.length}/${this.players.length}`);
                console.log('Artworks collected:', this.artworks.length);
                
                this.lockUserActions();
                
                const update = {
                    artworks: this.artworks,
                    submittedPlayers: this.submittedPlayers
                };
                this.broadcastUpdate(update);
                
                this.updateSubmissionStatus();
            }

            lockUserActions() {
                const submitBtn = document.getElementById('submitDrawing');
                if (submitBtn) submitBtn.disabled = true;
                
                const gameTimer = document.getElementById('gameTimer');
                if (gameTimer) {
                    gameTimer.textContent = `Waiting for other players... (${this.submittedPlayers.length}/${this.players.length})`;
                }
            }

            forceSubmitAll() {
                console.log('🚀 Force submitting all players due to timer expiry');
                
                const myPlayer = this.getMyPlayer();
                if (!myPlayer) return;
                
                if (!this.submittedPlayers) this.submittedPlayers = [];
                
                // Submit current player's drawing if not already submitted
                if (!this.submittedPlayers.includes(myPlayer.id)) {
                    let imageData;
                    if (window.bulletproofCanvas) {
                        imageData = window.bulletproofCanvas.getDrawingData();
                    } else {
                        imageData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
                    }
                    
                    const artwork = {
                        playerId: myPlayer.id,
                        playerName: myPlayer.name,
                        prompt: this.currentPrompt,
                        imageData: imageData,
                        actualValue: this.calculateArtworkValue()
                    };
                    
                    this.artworks = [...(this.artworks || []), artwork];
                    this.submittedPlayers.push(myPlayer.id);
                    
                    console.log(`📝 Auto-submitted drawing for ${myPlayer.name}`);
                }
                
                // Clean up drawing phase
                if (this.drawingTimer) {
                    clearInterval(this.drawingTimer);
                    this.drawingTimer = null;
                }
                
                this.hideRoundTimer();
                
                const submitBtn = document.getElementById('submitDrawing');
                if (submitBtn) submitBtn.disabled = true;
                
                // Force transition to bidding phase - ONLY HOST BROADCASTS
                if (roomManager.isHost) {
                    const update = {
                        phase: 'bidding',
                        artworks: this.artworks,
                        submittedPlayers: this.submittedPlayers,
                        currentAuctionIndex: 0,
                        currentBid: 0,
                        currentBidder: null
                    };
                    
                    this.broadcastUpdate(update);
                }
                
                console.log('🎯 Transitioning to bidding phase with all submissions collected');
                
                // Start bidding phase for everyone
                setTimeout(() => {
                    this.startBiddingPhase();
                }, 1000);
            }

            startBiddingPhase() {
                console.log('🎯 Starting bidding phase...');
                
                this.gameState = 'bidding';
                this.currentAuctionIndex = 0;
                this.submittedPlayers = [];
                this.drawingPhaseStarted = false; // Reset for next round
                
                const promptDisplay = document.getElementById('promptDisplay');
                const phaseInfo = document.getElementById('phaseInfo');
                const toolbar = document.querySelector('.toolbar');
                
                if (promptDisplay) promptDisplay.classList.remove('active');
                if (phaseInfo) phaseInfo.textContent = 'Bidding Phase';
                if (toolbar) toolbar.style.display = 'none';
                
                console.log(`Starting auction with ${this.artworks?.length || 0} artworks`);
                
                if (this.artworks && this.artworks.length > 0) {
                    // Host broadcasts bidding state to ensure everyone is synchronized
                    if (roomManager.isHost) {
                        this.broadcastUpdate({
                            phase: 'bidding',
                            artworks: this.artworks,
                            currentAuctionIndex: 0,
                            currentBid: 0,
                            currentBidder: null
                        });
                    }
                    
                    // Start the first auction immediately
                    setTimeout(() => {
                        this.startNextAuction();
                    }, 500);
                } else {
                    console.error('No artworks to auction!');
                    // If no artworks, skip to next round
                    this.endRound();
                }
                
                this.updateUI();
            }

            startNextAuction() {
                if (this.currentAuctionIndex >= this.artworks.length) {
                    this.endRound();
                    return;
                }
                
                this.currentArtwork = this.artworks[this.currentAuctionIndex];
                this.currentBid = 0;
                this.currentBidder = null;
                
                this.timeRemaining = this.gameSettings.biddingTime;
                this.showBiddingInterface();
                
                // Show auction timer in bottom left
                const roundTimer = document.getElementById('roundTimer');
                const timerLabel = document.querySelector('.timer-label');
                const timerPhase = document.getElementById('timerPhase');
                
                if (roundTimer) {
                    roundTimer.classList.add('active');
                    if (timerLabel) timerLabel.textContent = 'Auction Time';
                    if (timerPhase) timerPhase.textContent = `Artwork ${this.currentAuctionIndex + 1} of ${this.artworks.length}`;
                }
                
                if (this.biddingTimer) {
                    clearInterval(this.biddingTimer);
                }
                
                this.biddingTimer = setInterval(() => {
                    this.timeRemaining--;
                    this.updateRoundTimer();
                    this.updateBiddingTimer();
                    
                    if (this.timeRemaining <= 0) {
                        this.hideRoundTimer();
                        this.endAuction();
                    }
                }, 1000);
            }

            showBiddingInterface() {
                const overlay = document.getElementById('biddingOverlay');
                const artworkCanvas = document.getElementById('biddingArtwork');
                const ctx = artworkCanvas.getContext('2d');
                
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, artworkCanvas.width, artworkCanvas.height);
                    ctx.drawImage(img, 0, 0, artworkCanvas.width, artworkCanvas.height);
                };
                img.src = this.currentArtwork.imageData;
                
                document.getElementById('biddingPrompt').textContent = `"${this.currentArtwork.prompt}" by ${this.currentArtwork.playerName}`;
                document.getElementById('currentBid').textContent = `Current Bid: ${this.currentBid}`;
                document.getElementById('bidInput').value = Math.max(this.currentBid + 500, 500);
                
                overlay.classList.add('active');
                this.updateBiddingTimer();
            }

            placeBid(bidAmount = null) {
                let finalBidAmount;
                
                if (bidAmount !== null) {
                    // Quick bid button was used
                    finalBidAmount = this.currentBid + bidAmount;
                } else {
                    // Manual input was used
                    finalBidAmount = parseInt(document.getElementById('bidInput').value) || 0;
                }
                
                const myPlayer = this.getMyPlayer();
                
                if (!myPlayer) return;
                
                if (finalBidAmount <= this.currentBid) {
                    alert('Bid must be higher than current bid!');
                    return;
                }
                
                if (finalBidAmount > myPlayer.money) {
                    alert('You don\'t have enough money!');
                    return;
                }
                
                this.currentBid = finalBidAmount;
                this.currentBidder = myPlayer.id;
                
                // Immediately broadcast bid to all players
                const bidUpdate = {
                    type: 'bidUpdate',
                    currentBid: this.currentBid,
                    currentBidder: this.currentBidder,
                    bidderName: myPlayer.name
                };
                
                this.broadcastUpdate(bidUpdate);
                
                // Update local display
                document.getElementById('currentBid').textContent = `Current Bid: ${this.currentBid} (${myPlayer.name})`;
                document.getElementById('bidInput').value = this.currentBid + 500;
                
                this.updateUI();
            }

            calculateArtworkValue() {
                const baseValues = {
                    simple: Math.floor(Math.random() * 400) + 200,
                    medium: Math.floor(Math.random() * 600) + 400,
                    complex: Math.floor(Math.random() * 800) + 700
                };
                
                const complexPrompts = ['knight fighting', 'pirate ship', 'dragon flying', 'wizard making', 'robot eating'];
                const mediumPrompts = ['alien playing', 'superhero walking', 'unicorn riding', 'dinosaur wearing'];
                
                let category = 'simple';
                if (complexPrompts.some(phrase => this.currentPrompt.toLowerCase().includes(phrase.toLowerCase()))) {
                    category = 'complex';
                } else if (mediumPrompts.some(phrase => this.currentPrompt.toLowerCase().includes(phrase.toLowerCase()))) {
                    category = 'medium';
                }
                
                return baseValues[category];
            }

            endAuction() {
                if (this.biddingTimer) {
                    clearInterval(this.biddingTimer);
                    this.biddingTimer = null;
                }
                
                let resultMessage = '';
                
                if (this.currentBidder !== null && this.currentBid > 0) {
                    // Someone won the auction
                    const winner = this.players.find(p => p.id === this.currentBidder);
                    const seller = this.players.find(p => p.id === this.currentArtwork.playerId);
                    
                    if (winner && seller) {
                        // Update money for both players
                        winner.money -= this.currentBid;
                        seller.money += this.currentBid;
                        
                        resultMessage = `${winner.name} won "${this.currentArtwork.prompt}" for ${this.currentBid}!\nActual value was ${this.currentArtwork.actualValue}`;
                        
                        // Broadcast updated player money to all clients
                        if (roomManager.isHost) {
                            this.broadcastUpdate({
                                type: 'playerMoneyUpdate',
                                players: this.players
                            });
                        }
                        
                        if (roomManager) {
                            roomManager.sendMessage('chat', {
                                content: `${winner.name} bought "${this.currentArtwork.prompt}" for ${this.currentBid} (Value: ${this.currentArtwork.actualValue})`,
                                sender: 'Auction'
                            });
                        }
                    }
                } else {
                    // No bids placed
                    resultMessage = `No bids for "${this.currentArtwork.prompt}" (Value: ${this.currentArtwork.actualValue})`;
                    
                    if (roomManager) {
                        roomManager.sendMessage('chat', {
                            content: `No bids for "${this.currentArtwork.prompt}" (Value: ${this.currentArtwork.actualValue})`,
                            sender: 'Auction'
                        });
                    }
                }
                
                setTimeout(() => {
                    alert(resultMessage);
                }, 500);
                
                document.getElementById('biddingOverlay').classList.remove('active');
                
                this.currentAuctionIndex++;
                
                if (roomManager.isHost) {
                    const update = {
                        players: this.players,
                        currentAuctionIndex: this.currentAuctionIndex
                    };
                    this.broadcastUpdate(update);
                }
                
                setTimeout(() => {
                    this.startNextAuction();
                }, 1500);
                
                this.updateUI();
            }

            endRound() {
                this.drawingPhaseStarted = false; // Reset flag for next round
                this.currentRound++;
                this.currentPlayer = (this.currentPlayer + 1) % this.players.length;
                this.artworks = [];
                this.currentAuctionIndex = 0;
                this.currentPrompt = '';
                this.submittedPlayers = [];
                
                document.querySelector('.toolbar').style.display = 'flex';
                
                if (this.currentRound > this.maxRounds) {
                    if (roomManager.isHost) {
                        this.broadcastUpdate({ phase: 'results' });
                    }
                    this.endGame();
                } else {
                    if (roomManager.isHost) {
                        const update = {
                            phase: 'drawing',
                            round: this.currentRound,
                            currentPlayer: this.currentPlayer,
                            artworks: [],
                            currentAuctionIndex: 0,
                            currentPrompt: '',
                            submittedPlayers: []
                        };
                        this.broadcastUpdate(update);
                    }
                    setTimeout(() => {
                        this.startDrawingPhase();
                    }, 500);
                }
                
                this.updateUI();
            }

            endGame() {
                this.gameState = 'results';
                document.getElementById('phaseInfo').textContent = 'Game Complete';
                
                const sortedPlayers = [...this.players].sort((a, b) => b.money - a.money);
                
                const resultsModal = document.getElementById('resultsModal');
                const standingsDiv = document.getElementById('finalStandings');
                
                standingsDiv.innerHTML = '';
                sortedPlayers.forEach((player, index) => {
                    const standingItem = document.createElement('div');
                    let itemClass = 'standing-item';
                    let trophy = '';
                    
                    if (index === 0) {
                        itemClass += ' winner';
                        trophy = ' 🏆';
                    } else if (index === 1) {
                        itemClass += ' second';
                        trophy = ' 🥈';
                    } else if (index === 2) {
                        itemClass += ' third';
                        trophy = ' 🥉';
                    }
                    
                    standingItem.className = itemClass;
                    standingItem.innerHTML = `
                        <div>
                            <strong>${index + 1}. ${player.name}</strong>${trophy}
                            <br><small>Secret values: ${player.secretValues.low}-${player.secretValues.high}</small>
                        </div>
                        <div style="color: #27ae60; font-weight: bold;">${player.money.toLocaleString()}</div>
                    `;
                    standingsDiv.appendChild(standingItem);
                });
                
                resultsModal.classList.add('active');
                this.updateUI();
                
                if (roomManager && sortedPlayers.length > 0) {
                    roomManager.sendMessage('chat', {
                        content: `🎉 Game Over! ${sortedPlayers[0].name} wins with ${sortedPlayers[0].money.toLocaleString()}!`,
                        sender: 'System'
                    });
                }
            }

            resetGame() {
                this.gameState = 'lobby';
                this.currentRound = 1;
                this.currentPlayer = 0;
                this.players = [];
                this.currentPrompt = '';
                this.currentArtwork = null;
                this.currentBid = 0;
                this.currentBidder = null;
                this.artworks = [];
                this.currentAuctionIndex = 0;
                this.submittedPlayers = [];
                this.drawingPhaseStarted = false; // Reset flag
                
                if (this.drawingTimer) {
                    clearInterval(this.drawingTimer);
                    this.drawingTimer = null;
                }
                if (this.biddingTimer) {
                    clearInterval(this.biddingTimer);
                    this.biddingTimer = null;
                }
                
                this.hideRoundTimer();
                document.getElementById('resultsModal').classList.remove('active');
                document.getElementById('biddingOverlay').classList.remove('active');
                document.getElementById('promptDisplay').classList.remove('active');
                document.getElementById('lobbyModal').style.display = 'flex';
                document.querySelector('.toolbar').style.display = 'flex';
                
                if (window.bulletproofCanvas) {
                    window.bulletproofCanvas.manualClear();
                }
                
                roomManager.showMain();
                roomManager.updateConnectionStatus('Disconnected');
                this.updateUI();
            }

            updateTimer() {
                const timerDisplay = document.getElementById('gameTimer');
                if (!timerDisplay) return;
                
                const minutes = Math.floor(this.timeRemaining / 60);
                const seconds = this.timeRemaining % 60;
                timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                if (this.timeRemaining <= 10) {
                    timerDisplay.style.color = '#e74c3c';
                } else if (this.timeRemaining <= 30) {
                    timerDisplay.style.color = '#f39c12';
                } else {
                    timerDisplay.style.color = '#ffeb3b';
                }
            }

            updateBiddingTimer() {
                const timerDisplay = document.getElementById('bidTimer');
                if (!timerDisplay) return;
                
                timerDisplay.textContent = `Time Remaining: ${this.timeRemaining}s`;
                
                if (this.timeRemaining <= 5) {
                    timerDisplay.style.color = '#e74c3c';
                } else if (this.timeRemaining <= 15) {
                    timerDisplay.style.color = '#f39c12';
                } else {
                    timerDisplay.style.color = '#333';
                }
            }

            updateUI() {
                const myPlayer = this.getMyPlayer();
                if (myPlayer) {
                    document.getElementById('moneyDisplay').textContent = `Money: ${myPlayer.money.toLocaleString()}`;
                }
                
                document.getElementById('roundInfo').textContent = `Round ${this.currentRound} of ${this.maxRounds}`;
                this.updatePlayersList();
                
                // Update toolbar and canvas availability based on game state
                const toolbar = document.querySelector('.toolbar');
                const canvas = document.getElementById('bulletproof-canvas');
                
                if (this.gameState === 'lobby') {
                    document.getElementById('gameTimer').textContent = 'In Lobby';
                    document.getElementById('gameTimer').style.color = '#ffeb3b';
                    document.getElementById('phaseInfo').textContent = 'Lobby';
                    
                    // Disable drawing in lobby
                    if (toolbar) toolbar.style.opacity = '0.5';
                    if (canvas) canvas.style.opacity = '0.5';
                    
                } else if (this.gameState === 'drawing') {
                    // Enable drawing during drawing phase
                    if (toolbar) toolbar.style.opacity = '1';
                    if (canvas) canvas.style.opacity = '1';
                    
                } else if (this.gameState === 'bidding') {
                    document.getElementById('phaseInfo').textContent = 'Bidding Phase';
                    
                    // Disable drawing during bidding
                    if (toolbar) toolbar.style.opacity = '0.5';
                    if (canvas) canvas.style.opacity = '0.5';
                    
                } else if (this.gameState === 'results') {
                    document.getElementById('gameTimer').textContent = 'Game Complete';
                    document.getElementById('gameTimer').style.color = '#27ae60';
                    document.getElementById('phaseInfo').textContent = 'Game Complete';
                    
                    // Disable drawing after game
                    if (toolbar) toolbar.style.opacity = '0.5';
                    if (canvas) canvas.style.opacity = '0.5';
                }
            }

            updatePlayersList() {
                const playersList = document.getElementById('playersList');
                const playerCount = document.getElementById('playerCount');
                
                playersList.innerHTML = '';
                
                if (playerCount) {
                    playerCount.textContent = this.players.length;
                }
                
                this.players.forEach((player, index) => {
                    const playerItem = document.createElement('div');
                    playerItem.className = 'player-item';
                    
                    if (this.gameState === 'drawing' && index === this.currentPlayer) {
                        playerItem.style.backgroundColor = '#e3f2fd';
                        playerItem.style.borderLeft = '3px solid #2196f3';
                    }
                    
                    const isMe = player.id === roomManager.localPlayer?.id;
                    let statusText = 'Connected';
                    let statusClass = '';
                    
                    if (this.gameState === 'drawing' && this.submittedPlayers) {
                        if (this.submittedPlayers.includes(player.id)) {
                            statusText = 'Submitted';
                            statusClass = 'submitted';
                        } else {
                            statusText = 'Drawing...';
                            statusClass = 'drawing';
                        }
                    }
                    
                    playerItem.innerHTML = `
                        <div>
                            <div class="player-name">${player.name} ${isMe ? '(You)' : ''}</div>
                            <div class="player-values">Values: ${player.secretValues?.low || 0}-${player.secretValues?.high || 0}</div>
                            <div class="player-status ${statusClass}">${statusText}</div>
                        </div>
                        <div class="player-money">${player.money?.toLocaleString() || '0'}</div>
                    `;
                    
                    playersList.appendChild(playerItem);
                });
            }
        }

        // Enhanced Room Manager with Full Multiplayer
        class RoomManager {
            constructor() {
                this.isHost = false;
                this.currentRoom = null;
                this.players = [];
                this.maxPlayers = 4;
                this.gameSettings = {
                    maxPlayers: 4,
                    drawingTime: 90,
                    biddingTime: 30
                };
                this.localPlayer = null;
                this.pollInterval = null;
                this.broadcastChannel = null;
                this.processedMessages = new Set(); // Initialize processed messages tracker
                
                this.updateConnectionStatus('Ready to create or join a room');
            }

            initializeFastCommunication(roomCode) {
                try {
                    this.broadcastChannel = new BroadcastChannel(`game_room_${roomCode}`);
                    this.broadcastChannel.onmessage = (event) => {
                        this.handleBroadcastMessage(event.data);
                    };
                    console.log('Fast communication initialized');
                } catch (e) {
                    console.log('BroadcastChannel not supported, using localStorage only');
                }
            }

            handleBroadcastMessage(data) {
                if (data.from === this.localPlayer?.id) return;
                
                // Check for duplicate messages using message ID
                if (data.type === 'chat' && this.processedMessages && this.processedMessages.has(data.data.messageId)) {
                    return; // Skip duplicate chat messages
                }
                
                switch (data.type) {
                    case 'gameUpdate':
                        if (gameManager) {
                            gameManager.handleRemoteUpdate(data.data);
                        }
                        break;
                    case 'chat':
                        if (chatApp) {
                            chatApp.addMessage(data.data.content, data.data.sender, false);
                            // Mark chat message as processed
                            if (this.processedMessages && data.data.messageId) {
                                this.processedMessages.add(data.data.messageId);
                            }
                        }
                        break;
                    case 'playerJoined':
                        this.handlePlayerJoined(data.data);
                        break;
                }
            }

            fastBroadcast(type, data) {
                const message = {
                    type: type,
                    data: data,
                    from: this.localPlayer?.id,
                    timestamp: Date.now()
                };

                if (this.broadcastChannel) {
                    this.broadcastChannel.postMessage(message);
                }

                this.sendMessage(type, data);
            }

            updateConnectionStatus(status, type = '') {
                const statusEl = document.getElementById('connectionStatus');
                
                if (statusEl) {
                    let comMethod = '';
                    if (this.broadcastChannel) {
                        comMethod = ' (Fast Mode)';
                    } else {
                        comMethod = ' (Standard Mode)';
                    }
                    statusEl.textContent = status + comMethod;
                    statusEl.className = `connection-status ${type}`;
                }
            }

            showMain() {
                document.getElementById('lobbyMain').style.display = 'block';
                document.getElementById('createRoomForm').style.display = 'none';
                document.getElementById('joinRoomForm').style.display = 'none';
            }

            showJoinRoom() {
                document.getElementById('lobbyMain').style.display = 'none';
                document.getElementById('joinRoomForm').style.display = 'block';
            }

            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let result = '';
                for (let i = 0; i < 4; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            createRoom() {
                this.isHost = true;
                this.currentRoom = this.generateRoomCode();
                
                this.gameSettings.maxPlayers = parseInt(document.getElementById('maxPlayers').value);
                this.gameSettings.drawingTime = parseInt(document.getElementById('drawingTime').value);
                this.gameSettings.biddingTime = parseInt(document.getElementById('biddingTime').value);
                
                this.localPlayer = { 
                    id: 'host', 
                    name: 'Host', 
                    isHost: true,
                    timestamp: Date.now(),
                    lastSeen: Date.now(),
                    money: 10000
                };

                const roomData = {
                    code: this.currentRoom,
                    host: this.localPlayer.id,
                    players: [this.localPlayer],
                    status: 'waiting',
                    created: Date.now(),
                    gameState: null,
                    settings: this.gameSettings,
                    lastActivity: Date.now()
                };

                localStorage.setItem(`room_${this.currentRoom}`, JSON.stringify(roomData));

                this.initializeFastCommunication(this.currentRoom);

                this.players = [this.localPlayer];
                
                if (gameManager) {
                    gameManager.players = this.players;
                    gameManager.updateUI();
                }

                document.getElementById('lobbyMain').style.display = 'none';
                document.getElementById('createRoomForm').style.display = 'block';
                document.getElementById('roomCode').textContent = this.currentRoom;

                this.startPolling();
                chatApp.enableChat();
                this.updateConnectionStatus(`Room ${this.currentRoom} created - waiting for players`, 'connected');
            }

            async joinRoom() {
                const playerName = document.getElementById('playerName').value.trim() || 'Player';
                const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();

                if (roomCode.length !== 4) {
                    alert('Please enter a valid 4-letter room code!');
                    return;
                }

                const roomData = JSON.parse(localStorage.getItem(`room_${roomCode}`) || 'null');
                if (!roomData) {
                    alert('Room not found! Please check the code.');
                    return;
                }

                if (roomData.status !== 'waiting') {
                    alert('This room is not available for joining.');
                    return;
                }

                if (roomData.players.length >= roomData.settings.maxPlayers) {
                    alert(`Room is full! Maximum ${roomData.settings.maxPlayers} players allowed.`);
                    return;
                }

                if (roomData.players.some(p => p.name === playerName)) {
                    alert('A player with this name is already in the room. Please choose a different name.');
                    return;
                }

                this.isHost = false;
                this.currentRoom = roomCode;
                this.gameSettings = roomData.settings;
                
                this.localPlayer = { 
                    id: Math.random().toString(36).substr(2, 9), 
                    name: playerName, 
                    isHost: false,
                    timestamp: Date.now(),
                    lastSeen: Date.now(),
                    money: 10000
                };

                roomData.players.push(this.localPlayer);
                roomData.lastActivity = Date.now();
                localStorage.setItem(`room_${roomCode}`, JSON.stringify(roomData));

                this.initializeFastCommunication(roomCode);

                this.fastBroadcast('playerJoined', {
                    player: this.localPlayer,
                    roomCode: roomCode
                });

                this.players = roomData.players;
                
                if (gameManager) {
                    gameManager.players = this.players;
                    gameManager.updateUI();
                }

                document.getElementById('lobbyModal').style.display = 'none';
                this.startPolling();
                chatApp.enableChat();
                this.updateConnectionStatus(`Joined room ${roomCode}`, 'connected');
            }

            startPolling() {
                this.pollInterval = setInterval(() => {
                    this.pollRoomUpdates();
                    this.sendHeartbeat();
                    this.cleanupDisconnectedPlayers();
                }, 1000); // Reduced frequency to prevent race conditions
            }

            sendHeartbeat() {
                if (!this.currentRoom || !this.localPlayer) return;
                
                const roomData = JSON.parse(localStorage.getItem(`room_${this.currentRoom}`) || '{}');
                if (!roomData.players) return;
                
                const playerIndex = roomData.players.findIndex(p => p.id === this.localPlayer.id);
                if (playerIndex !== -1) {
                    roomData.players[playerIndex].lastSeen = Date.now();
                    roomData.lastActivity = Date.now();
                    localStorage.setItem(`room_${this.currentRoom}`, JSON.stringify(roomData));
                }
            }

            cleanupDisconnectedPlayers() {
                if (!this.isHost || !this.currentRoom) return;
                
                const roomData = JSON.parse(localStorage.getItem(`room_${this.currentRoom}`) || '{}');
                if (!roomData.players) return;
                
                const now = Date.now();
                const timeoutMs = 15000; // Increased timeout to 15 seconds
                
                const activePlayers = roomData.players.filter(player => {
                    if (player.id === this.localPlayer.id) return true;
                    return (now - player.lastSeen) < timeoutMs;
                });
                
                // Only update if there's actually a change to prevent unnecessary updates
                if (activePlayers.length !== roomData.players.length) {
                    console.log(`Removing ${roomData.players.length - activePlayers.length} disconnected players`);
                    roomData.players = activePlayers;
                    roomData.lastActivity = now;
                    localStorage.setItem(`room_${this.currentRoom}`, JSON.stringify(roomData));
                }
            }

            pollRoomUpdates() {
                if (!this.currentRoom) return;

                const roomData = JSON.parse(localStorage.getItem(`room_${this.currentRoom}`) || 'null');
                if (!roomData) {
                    this.updateConnectionStatus('Room no longer exists', 'error');
                    this.leaveRoom();
                    return;
                }

                this.players = roomData.players || [];
                this.updatePlayersDisplay();

                if (gameManager && gameManager.players.length === 0 && this.players.length > 0) {
                    gameManager.players = this.players;
                    gameManager.updateUI();
                }

                if (roomData.status === 'playing' && roomData.gameState) {
                    this.joinActiveGame(roomData.gameState);
                }

                if (roomData.messages) {
                    if (!this.processedMessages) {
                        this.processedMessages = new Set();
                    }
                    
                    roomData.messages.forEach(msg => {
                        if (msg.id && !this.processedMessages.has(msg.id)) {
                            this.handleMessage(msg);
                            this.processedMessages.add(msg.id);
                        }
                    });
                }
            }

            updatePlayersDisplay() {
                const waitingDiv = document.getElementById('waitingPlayers');
                const playerCount = document.getElementById('playerCount');
                
                if (playerCount) {
                    playerCount.textContent = this.players.length;
                }
                
                const content = '<h4>Players in room:</h4>' + 
                    this.players.map(p => {
                        const status = p.id === this.localPlayer?.id ? ' (You)' : '';
                        const host = p.isHost ? ' (Host)' : '';
                        return `<div>${p.name}${status}${host}</div>`;
                    }).join('');

                if (waitingDiv) waitingDiv.innerHTML = content;

                const progressFill = Math.min(100, (this.players.length / this.gameSettings.maxPlayers) * 100);
                const playerProgress = document.getElementById('playerProgress');
                
                if (playerProgress) playerProgress.style.width = `${progressFill}%`;

                const startBtn = document.getElementById('startGameBtn');
                if (startBtn && this.isHost && this.players.length >= 2) {
                    startBtn.style.display = 'block';
                    startBtn.textContent = `Start Game (${this.players.length}/${this.gameSettings.maxPlayers} players)`;
                } else if (startBtn) {
                    startBtn.style.display = 'none';
                }

                this.updateGamePlayersList();
            }

            updateGamePlayersList() {
                const playersList = document.getElementById('playersList');
                const playerCount = document.getElementById('playerCount');
                
                if (!playersList) return;
                
                playersList.innerHTML = '';
                
                if (playerCount) {
                    playerCount.textContent = this.players.length;
                }
                
                this.players.forEach((player, index) => {
                    const playerItem = document.createElement('div');
                    playerItem.className = 'player-item';
                    
                    const isMe = player.id === this.localPlayer?.id;
                    
                    playerItem.innerHTML = `
                        <div>
                            <div class="player-name">${player.name} ${isMe ? '(You)' : ''}</div>
                            <div class="player-values">Values: ${player.secretValues?.low || 0}-${player.secretValues?.high || 0}</div>
                            <div class="player-status">Connected</div>
                        </div>
                        <div class="player-money">${player.money?.toLocaleString() || '10,000'}</div>
                    `;
                    
                    playersList.appendChild(playerItem);
                });
            }

            sendMessage(type, data) {
                if (!this.currentRoom) return;

                const roomData = JSON.parse(localStorage.getItem(`room_${this.currentRoom}`) || '{}');
                if (!roomData.messages) roomData.messages = [];

                const message = {
                    id: Math.random().toString(36).substr(2, 9),
                    type: type,
                    data: data,
                    from: this.localPlayer.id,
                    timestamp: Date.now()
                };

                roomData.messages.push(message);
                
                if (roomData.messages.length > 100) {
                    roomData.messages = roomData.messages.slice(-100);
                }

                roomData.lastActivity = Date.now();
                localStorage.setItem(`room_${this.currentRoom}`, JSON.stringify(roomData));
            }

            handleMessage(message) {
                if (message.from === this.localPlayer.id) return;

                // Add unique message ID check to prevent duplicates
                if (this.processedMessages && this.processedMessages.has(message.id)) {
                    return; // Skip duplicate messages
                }

                switch (message.type) {
                    case 'gameUpdate':
                        if (gameManager) {
                            gameManager.handleRemoteUpdate(message.data);
                        }
                        break;
                    case 'chat':
                        if (chatApp) {
                            chatApp.addMessage(message.data.content, message.data.sender, false);
                        }
                        break;
                }

                // Mark message as processed
                if (this.processedMessages) {
                    this.processedMessages.add(message.id);
                }
            }

            startGame() {
                if (!this.isHost || this.players.length < 2) {
                    alert('Need at least 2 players to start the game!');
                    return;
                }

                const players = this.players.map((player, index) => ({
                    ...player,
                    money: 10000,
                    secretValues: {
                        low: Math.floor(Math.random() * 500) + 200,
                        high: Math.floor(Math.random() * 1000) + 800
                    }
                }));

                const gameState = {
                    players: players,
                    phase: 'drawing',
                    round: 1,
                    currentPlayer: 0,
                    settings: this.gameSettings
                };

                const roomData = JSON.parse(localStorage.getItem(`room_${this.currentRoom}`) || '{}');
                roomData.status = 'playing';
                roomData.gameState = gameState;
                roomData.lastActivity = Date.now();
                localStorage.setItem(`room_${this.currentRoom}`, JSON.stringify(roomData));

                this.joinActiveGame(gameState);
            }

            joinActiveGame(gameState) {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                }

                document.getElementById('lobbyModal').style.display = 'none';
                gameManager.initializeFromRoom(gameState);
                
                // Only enable chat if not already enabled
                if (!chatApp.enabled) {
                    chatApp.enableChat();
                }
                
                this.startPolling();
            }

            handlePlayerJoined(data) {
                if (data.player && data.roomCode === this.currentRoom) {
                    console.log('Player joined:', data.player.name);
                }
            }

            closeRoom() {
                if (this.currentRoom) {
                    localStorage.removeItem(`room_${this.currentRoom}`);
                }
                this.leaveRoom();
            }

            leaveRoom() {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                }

                if (this.currentRoom && this.localPlayer && !this.isHost) {
                    const roomData = JSON.parse(localStorage.getItem(`room_${this.currentRoom}`) || '{}');
                    if (roomData.players) {
                        roomData.players = roomData.players.filter(p => p.id !== this.localPlayer.id);
                        roomData.lastActivity = Date.now();
                        localStorage.setItem(`room_${this.currentRoom}`, JSON.stringify(roomData));
                    }
                }

                this.currentRoom = null;
                this.localPlayer = null;
                this.players = [];
                this.isHost = false;
                this.processedMessages = null;
                
                this.showMain();
                this.updateConnectionStatus('Disconnected');
                document.getElementById('playerCount').textContent = '0';
            }
        }

        // Enhanced Chat System
        class ChatApp {
            constructor() {
                this.chatMessages = document.getElementById('chatMessages');
                this.chatInput = document.getElementById('chatInput');
                this.messageCount = 1;
                this.enabled = false;
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                this.chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
            }

            enableChat() {
                if (this.enabled) return; // Don't reset if already enabled
                
                this.enabled = true;
                this.chatInput.disabled = false;
                this.chatInput.placeholder = "Type a message...";
                
                // Only clear messages if this is the first time enabling
                if (this.messageCount === 1) {
                    this.chatMessages.innerHTML = '';
                    this.addMessage('Chat enabled! Say hello to other players.', 'System', false);
                }
            }

            sendMessage() {
                if (!this.enabled) return;
                
                const message = this.chatInput.value.trim();
                if (!message || !roomManager.localPlayer) return;
                
                if (message.length > 500) {
                    alert('Message too long! Maximum 500 characters.');
                    return;
                }
                
                const messageId = Math.random().toString(36).substr(2, 9);
                
                roomManager.fastBroadcast('chat', {
                    messageId: messageId,
                    content: message,
                    sender: roomManager.localPlayer.name,
                    timestamp: Date.now()
                });
                
                this.addMessage(message, roomManager.localPlayer.name, true);
                this.chatInput.value = '';
            }
            
            addMessage(content, sender, isOwn = false) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isOwn ? 'own' : ''}`;
                
                const timestamp = sender === 'System' || sender === 'Auction' ? 
                    new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
                
                messageDiv.innerHTML = `
                    <div class="sender">${sender}${timestamp ? ` (${timestamp})` : ''}</div>
                    <div class="content">${this.escapeHtml(content)}</div>
                `;
                
                this.chatMessages.appendChild(messageDiv);
                this.messageCount++;
                
                this.scrollToBottom();
                this.manageFadeEffect();
            }
            
            scrollToBottom() {
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }
            
            manageFadeEffect() {
                const messages = this.chatMessages.querySelectorAll('.message');
                
                if (messages.length > 30) {
                    for (let i = 0; i < messages.length - 30; i++) {
                        messages[i].remove();
                    }
                }
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // Global variables
        let bulletproofCanvas;
        let gameManager;
        let roomManager;
        let chatApp;

        // Copy to clipboard utility
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            const text = element.textContent;
            navigator.clipboard.writeText(text).then(() => {
                alert('Copied to clipboard!');
            });
        }

        // Initialize everything
        window.addEventListener('load', () => {
            console.log('🚀 INITIALIZING BULLETPROOF GAME SYSTEM');
            
            // Initialize bulletproof canvas FIRST - this is the core drawing system
            window.bulletproofCanvas = new BulletproofCanvas();
            
            // Initialize full game systems with complete UI
            gameManager = new GameManager();
            roomManager = new RoomManager();
            chatApp = new ChatApp();
            
            // Clean up old rooms on page load
            const keys = Object.keys(localStorage);
            const now = Date.now();
            keys.forEach(key => {
                if (key.startsWith('room_')) {
                    const roomData = JSON.parse(localStorage.getItem(key) || '{}');
                    if (roomData.created && (now - roomData.created) > 3600000) {
                        localStorage.removeItem(key);
                    }
                }
            });
            
            console.log('✅ ALL SYSTEMS INITIALIZED - BULLETPROOF DRAWING + FULL UI ACTIVE');
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (roomManager && roomManager.currentRoom && roomManager.localPlayer) {
                roomManager.leaveRoom();
            }
        });
    </script>
</body>
</html>
